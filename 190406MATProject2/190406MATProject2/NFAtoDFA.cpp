#include <sstream>
#include <iostream>
#include <fstream>
#include <string>
#include <vector>
#include <algorithm>
using namespace std;

//Represents an NFA edge
struct edge {
	int origin;
	int destination;
	char transition;
	string DFADestination;		//Given by the name of the state
};

//Represents a DFA state along with the set and epsilon closure it represents
struct DFAstate {
	string name;						//The name is generated by the closures it represents
	vector<edge> edges;
	vector<int> epsilonClosure;
};

vector<DFAstate> convertToDFA(int sizeOfAlphabet, int initialState, vector<int>finalStateNodes, vector<edge>transitions, int numberOfStates);
vector<vector<edge>> sortTransitions(vector<edge> transitions, int numberOfStates);
vector<vector<int>> getEpsilonClosuresAllStates(vector<vector<edge>> sortedTransitions);
vector<int> getEpsilonClosure(int index, vector<vector<edge>> sortedTransitions);
string getDFAStateName(DFAstate origin);
vector<edge> getEdgesFromEClosure(DFAstate state, vector<vector<edge>> transitionsNFA, int sizeOfAlphabet, vector<vector<int>> epsilonClosures);
char toAlphabet(int i);
vector<int> getEpsilonClosureFromName(string name);
vector<int> removeDupes(vector<int> destinations);
void generateTxt(vector<DFAstate> DFA, int sizeOfAlphabet, vector<int> finalStateNodes);
vector<int> getFinalStates(vector<int> finalStatesNFA, vector<DFAstate> DFA);
int getEdgeCount(vector<DFAstate> DFA);
void writeTxt(int numberOfStates, int sizeOfAlphabet, int numberOfFinalStates, vector<int> finalStateNodesDFA, int numberOfMovements, vector<DFAstate> DFA);
vector<DFAstate> getDFANames(vector<DFAstate> DFA);
int getIndexFromName(string name, vector<DFAstate> DFA);

//Populate the variables given in the txt
void readAutomata(int * numberOfStates, int * sizeOfAlphabet, int * numberOfFinals, int * numberOfEdges, vector<int> * finalStateNodes, vector<edge> * transitions) {
	string line;
	ifstream myfile("automata1.txt");
	if (myfile.is_open()) {
		getline(myfile, line);
		*numberOfStates = stoi(line);
		getline(myfile, line);
		*sizeOfAlphabet = stoi(line);
		getline(myfile, line);
		*numberOfFinals = stoi(line);

		for (int i = 0; i < *numberOfFinals; i++) {
			getline(myfile, line);
			finalStateNodes->push_back(stoi(line));
		}

		getline(myfile, line);
		*numberOfEdges = stoi(line);

		for (int i = 0; i < *numberOfEdges; i++) {
			getline(myfile, line);
			edge temp;	//Temporary edge to be pushed in to vector
			//Split the line in to origin, destination, transition
			istringstream iss(line);
			string s;

			getline(iss, s, ' ');
			temp.origin = stoi(s);
			getline(iss, s, ' ');
			temp.destination = stoi(s);
			getline(iss, s, ' ');
			temp.transition = s[0];		//Assuming the trasition is one character, s[0] is one the first char of the one character string
			transitions->push_back(temp);
		}

		myfile.close();
	}
	else cout << "Unable to open file";
}

void main() {
	int x;

	//Variable declaration
	int numberOfStates;	//Number of states
	int sizeOfAlphabet;	//Symbols in the alphabet
	int numberOfFinals;	//Number of final states
	int numberOfEdges;	//Number of edges
	int initialState = 0;	//Start node

	vector<int> finalStateNodes;	//Nodes that are final
	vector<edge> transitions;		//Transitions
	vector<DFAstate> DFA;

	readAutomata(&numberOfStates, &sizeOfAlphabet, &numberOfFinals, &numberOfEdges, &finalStateNodes, &transitions);
	DFA = convertToDFA(sizeOfAlphabet, initialState, finalStateNodes, transitions, numberOfStates);

	generateTxt(DFA, sizeOfAlphabet, finalStateNodes);

	cin >> x;
}

//Get the variables needed for the txt, then call a function to write it
void generateTxt(vector<DFAstate> DFA, int sizeOfAlphabet, vector<int> finalStateNodes) {
	int numberOfStates = DFA.size();
	sizeOfAlphabet--;					//We don't count the null character anymore
	vector<int> finalStateNodesDFA = getFinalStates(finalStateNodes, DFA);
	int numberOfFinalStates = finalStateNodesDFA.size();
	int numberOfMovements = getEdgeCount(DFA);
	DFA = getDFANames(DFA);
	writeTxt(numberOfStates, sizeOfAlphabet, numberOfFinalStates, finalStateNodesDFA, numberOfMovements, DFA);
}

//Sets an single number 'origin' on edges to avoid using the multi-number name
vector<DFAstate> getDFANames(vector<DFAstate> DFA) {
	for (int i = 0; i < DFA.size(); i++) {		//For each state
		for (int j = 0; j < DFA[i].edges.size(); j++) {	//For each of its edges
			string nameToFind = DFA[i].edges[j].DFADestination;		//E-closure derived named
			DFA[i].edges[j].destination = getIndexFromName(nameToFind, DFA);
		}
	}
	return DFA;
}

//Returns the index at which a DFA name match is found
int getIndexFromName(string name, vector<DFAstate> DFA) {
	for (int i = 0; i < DFA.size(); i++) {
		if (DFA[i].name == name) {
			return i;	//Naming is done through the index
		}
	}
	cout << "Damn, didn't find " << name << endl;
}

//Write to file
void writeTxt(int numberOfStates, int sizeOfAlphabet, int numberOfFinalStates, vector<int> finalStateNodesDFA, int numberOfMovements, vector<DFAstate> DFA) {
	ofstream myfile;
	myfile.open("output.txt");
	//Number of states
	//cout << "States no.: " << numberOfStates << endl;
	myfile << numberOfStates << "\n";
	//Alphabet size
	//cout << "Alpha size: " << sizeOfAlphabet << endl;
	myfile << sizeOfAlphabet << "\n";
	//Numer of final states
	//cout << "Final no.: " << numberOfFinalStates << endl;
	myfile << numberOfFinalStates << "\n";
	//Final states
	//cout << "Final states: " << endl;
	for (int i = 0; i < finalStateNodesDFA.size(); i++) {
		//cout << finalStateNodesDFA[i] << endl;
		myfile << finalStateNodesDFA[i] << "\n";
	}
	//Number of edges
	//cout << "Move no.: " << numberOfMovements << endl;
	myfile << numberOfMovements << "\n";
	//Edges - Origin, Destination, Symbol
	//cout << "DFA" << endl;
	for (int i = 0; i < DFA.size(); i++) {
		for (int j = 0; j < DFA[i].edges.size(); j++) {
			//cout << i << " " << DFA[i].edges[j].destination << " " << toAlphabet(DFA[i].edges[j].transition) << endl;
			myfile << i << " " << DFA[i].edges[j].destination << " " << toAlphabet(DFA[i].edges[j].transition) << "\n";
		}
	}

	myfile.close();
}

//Counts the edges in a DFA and returns the number
int getEdgeCount(vector<DFAstate> DFA) {
	int count = 0;
	for (int i = 0; i < DFA.size(); i++) {
		for (int j = 0; j < DFA[i].edges.size(); j++) {
			count++;
		}
	}
	return count;
}

//Figure out which are finals and return
vector<int> getFinalStates(vector<int> finalStatesNFA, vector<DFAstate> DFA) {
	vector<int> finalStatesDFA;
	for (int i = 0; i < DFA.size(); i++) {		//For each DFA state
		for (int k = 0; k < DFA[i].epsilonClosure.size(); k++){		//Could use the name too, but the E-closure is easier to search since it's all ints
			for (int j = 0; j < finalStatesNFA.size(); j++) {			//For every end node in the original NFA
				if (DFA[i].epsilonClosure[k] == finalStatesNFA[j]) {	//If the E-closure set value is equal to the final state value (e.g. "1 2 3" contains "3")
					finalStatesDFA.push_back(i);		//First time using a single number as a DFA identifier
				}
			}
		}
	}
	finalStatesDFA = removeDupes(finalStatesDFA);
	return finalStatesDFA;
}

//Do the stuff
vector<DFAstate> convertToDFA(int sizeOfAlphabet, int initialState, vector<int>finalStateNodes, vector<edge>transitions, int numberOfStates) {
	vector<vector<edge>> sortedTransitions = sortTransitions(transitions, numberOfStates);	//Sort the transitions in to an ordered list of vectors
	vector<vector<int>> epsilonClosures = getEpsilonClosuresAllStates(sortedTransitions);	//Get epsilon closures for each state

	vector<DFAstate> uncheckedStates;	//This is a vector of DFA states that we know exist but need to check the edges of
	vector<DFAstate> checkedStates;

	//Define origin node
	DFAstate origin;
	origin.epsilonClosure = epsilonClosures[initialState];
	origin.name = getDFAStateName(origin);
	uncheckedStates.push_back(origin);	//Push it in to the unchecked since we don't know where it leads to
	//While there are still unchecked nodes
	while (uncheckedStates.size() > 0) {
		DFAstate checkingState = uncheckedStates.back();	//Get the last state in the vector, doesn't really matter if it's last or first
		uncheckedStates.pop_back();							//Remove it from the vector as it's going to be checked
		checkingState.edges = getEdgesFromEClosure(checkingState, sortedTransitions, sizeOfAlphabet, epsilonClosures);
		checkedStates.push_back(checkingState);		//The state has now been checked

		for (int i = 0; i < checkingState.edges.size(); i++) {	//Check to see if new states were discovered
			int found = 0;
			for (int j = 0; j < checkedStates.size(); j++) {
				if (checkingState.edges[i].DFADestination == checkedStates[j].name) {
					found = 1;
				}
			}
			for (int j = 0; j < uncheckedStates.size(); j++) {
				if (checkingState.edges[i].DFADestination == uncheckedStates[j].name) {
					found = 1;
				}
			}
			//If it's a new state
			if (!found) {
				DFAstate tmp;
				tmp.name = checkingState.edges[i].DFADestination;
				tmp.epsilonClosure = getEpsilonClosureFromName(tmp.name);
				uncheckedStates.push_back(tmp);		//Push it in to the unchecked queue
			}
		}
	}
	
	return checkedStates;
}

//Loops through where the epsilon states of the DFA state can take it with all the letter of the alphabet... or something
vector<edge> getEdgesFromEClosure(DFAstate state, vector<vector<edge>> transitionsNFA, int sizeOfAlphabet, vector<vector<int>> epsilonClosures) {
	vector<edge> edges;
	vector<int> destinations;	//Temporarily hold discovered destinations for the duration of a letter search
	for (int i = 0; i < sizeOfAlphabet - 1; i++) {	//For each letter of the alphabet i is the letter of the alphabet
		for (int j = 0; j < state.epsilonClosure.size(); j++) {	//For each state in the epsilon closure
			for (int k = 0; k < transitionsNFA[state.epsilonClosure[j]].size(); k++) {	//For each transition pertaining to the state
				if (transitionsNFA[state.epsilonClosure[j]][k].transition == toAlphabet(i)) {		//If the transition state is the letter being considered
					destinations.push_back(transitionsNFA[state.epsilonClosure[j]][k].destination);
				}
			}
			if (destinations.size() > 0) {		//If destinations.size() is 0, then this state leads nowhere
				destinations = removeDupes(destinations);
				edge tmp;
				tmp.transition = i;
				string destName = "";
				for (int k = 0; k < destinations.size(); k++) {	//For each destination
					for (int l = 0; l < epsilonClosures[destinations[k]].size(); l++) {
						destName += to_string(epsilonClosures[destinations[k]][l]) + " ";		//The name is given by the state the letter takes you to plus its epsilon closures
					}
				}
				tmp.DFADestination = destName;		//A name such as "0 3 5"
				edges.push_back(tmp);
			}
			destinations.clear();	//Get ready to check the next letter
		}
	}
	return edges;
}


//Remove duplicate numbers from a vector of ints - thanks https://stackoverflow.com/questions/1041620/whats-the-most-efficient-way-to-erase-duplicates-and-sort-a-vector
vector<int> removeDupes(vector<int> destinations) {
	sort(destinations.begin(), destinations.end());
	destinations.erase(unique(destinations.begin(), destinations.end()), destinations.end());
	return destinations;
}

//Splits the name in to a vector of ints - thanks https://stackoverflow.com/questions/10058606/splitting-a-string-by-a-character
vector<int> getEpsilonClosureFromName(string name) {
	vector<int> eClosure;
	stringstream test(name);
	string segment;
	vector<string> seglist;
	while (getline(test, segment, ' '))
	{
		eClosure.push_back(stoi(segment));
	}
	return eClosure;
}

//Gets the name of a DFA from the epsilon closure it represents
string getDFAStateName(DFAstate origin) {
	string name = "";
	for (int i = 0; i < origin.epsilonClosure.size(); i++) {
		name += to_string(origin.epsilonClosure[i]) + " ";
	}
	return name;
}

char toAlphabet(int i) {
	switch (i) {
	case 0: return 'a';
	case 1: return 'b';
	case 2: return 'c';
	case 3: return 'd';
	case 4: return 'e';
	//f is null
	case 5: return 'g';
	case 6: return 'h';
	case 7: return 'i';
	case 8: return 'j';
	case 9: return 'k';
	}
}

//Returns a list of vector<edge> where the index represents the node number
vector<vector<edge>> sortTransitions(vector<edge> transitions, int numberOfStates) {
	vector<vector<edge>> sortedTransitions;
	//For each state, push in a vector to represent it as an origin
	for (int i = 0; i < numberOfStates; i++) {
		vector<edge> tmp;
		sortedTransitions.push_back(tmp);
	}

	//For each transition, deposit its origin and state required in to the vector<vector<edge>>
	for (int i = 0; i < transitions.size(); i++) {
		sortedTransitions[transitions[i].origin].push_back(transitions[i]);	//The origin is still an attribute of the edge even though it's redundant
	}

	return sortedTransitions;
}

vector<vector<int>> getEpsilonClosuresAllStates(vector<vector<edge>> sortedTransitions) {
	vector <vector<int>> epsilonClosures;

	//For each state, push in a vector to represent it as an origin
	for (int i = 0; i < sortedTransitions.size(); i++) {
		vector<int> tmp;
		epsilonClosures.push_back(tmp);
	}

	//This has a lot of redundancy since the same E-closures are checked many time - can be optimised 
	for (int i = 0; i < sortedTransitions.size(); i++) {
		epsilonClosures[i] = getEpsilonClosure(i, sortedTransitions);	//Get an indvidual E-closure
	}

	return epsilonClosures;
}

//Returns a vector of indices relating to an epsilon closure
vector<int> getEpsilonClosure(int index, vector<vector<edge>> sortedTransitions) {
	vector<int> epsilonClosure;
	epsilonClosure.push_back(index);	//The node iteslf is always included
	for (int i = 0; i < sortedTransitions[index].size(); i++) {		//For each edge
		if (sortedTransitions[index][i].transition == 'f') {		//If its destination node is null
			vector<int> rabbitHole = getEpsilonClosure(sortedTransitions[index][i].destination, sortedTransitions);	//Get the epsilon closure of a destination node
			copy(rabbitHole.begin(), rabbitHole.end(), back_inserter(epsilonClosure));		//Append the returned vector to the epsilon vector
		}
	}
	return epsilonClosure;
}